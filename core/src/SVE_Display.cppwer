#include "SVE_Display.hpp"

void SVE_Display::bindDevice(SVE_Device& sveDevice, VkPresentModeKHR presentMode) {
    device = &sveDevice;
    const VkColorSpaceKHR requested_colorspace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
    VkSurfaceFormatKHR surface_format = vkl::pickSurfaceFormat(sveDevice.physical, surface, { VK_FORMAT_B8G8R8A8_SRGB, VK_COLORSPACE_SRGB_NONLINEAR_KHR });
    VkPresentModeKHR present_mode = vkl::pickPresentMode(_Physical, _Surface, ARRAY_SIZE(PRESENT_MODES), PRESENT_MODES);

    swapchain = vkl::createSwapchain(_Logical, _Physical, _Surface, _PresentIndex, _GraphicsIndex, { _WindowWidth, _WindowHeight }, surface_format, present_mode);

    VkFormat depth_format = vkl::findSupportedFormat(_Physical, ARRAY_SIZE(POSSIBLE_DEPTH_FORMATS), POSSIBLE_DEPTH_FORMATS, VK_IMAGE_TILING_OPTIMAL, VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);
    // render pass:
    {
        SVE::logInfo("creating render passes: ");
        VkAttachmentDescription attachments[] = {
            vkl::createAttachmentDescription(surface_format.format, VK_SAMPLE_COUNT_1_BIT,
            VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE,
            VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE,
            VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR),
            vkl::createAttachmentDescription(depth_format, VK_SAMPLE_COUNT_1_BIT,
            VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE,
            VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE,
            VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL)
        };
        VkAttachmentReference color_ref = vkl::createAttachmentReference(0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);
        VkAttachmentReference depth_ref = vkl::createAttachmentReference(1, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);
        VkSubpassDescription subpasses[] = {
            vkl::createSubpassDescription(VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, 1, &color_ref, nullptr, depth_ref, 0, nullptr)
        };
        VkSubpassDependency dependencies[] = {
            vkl::createSubpassDependency(VK_SUBPASS_EXTERNAL, 0,
            VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
            0, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT)
        };
        _RenderPass = vkl::createRenderPass(_Logical, ARRAY_SIZE(attachments), attachments, ARRAY_SIZE(subpasses), subpasses, ARRAY_SIZE(dependencies), dependencies);
        _DepthImage = vkl::createImage2D(_Logical, depth_format, _WindowWidth, _WindowHeight, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT);
        _AttachmentMemory = vkl::allocateForImage(_Logical, _Physical, _DepthImage, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
        _DepthImageView = vkl::createImageView2D(_Logical, _DepthImage, depth_format, VK_IMAGE_ASPECT_DEPTH_BIT);

        auto images = vkl::getSwapchainImages(_Logical, _Swapchain);
        _ImageResources.resize(images.size());
        for (size_t i = 0; i < images.size(); ++i) {
            _ImageResources[i].image = images[i];
            _ImageResources[i].imageView = vkl::createImageView2D(_Logical, images[i], surface_format.format);
            _ImageResources[i].commandPool = vkl::createCommandPool(_Logical, _GraphicsIndex);
            _ImageResources[i].primaryCommands = vkl::createCommandBuffer(_Logical, _ImageResources[i].commandPool, VK_COMMAND_BUFFER_LEVEL_PRIMARY);
            VkImageView attachments[] = { _ImageResources[i].imageView, _DepthImageView };
            _ImageResources[i].framebuffer = vkl::createFramebuffer(_Logical, _RenderPass, ARRAY_SIZE(attachments), attachments, _WindowWidth, _WindowHeight, 1);
        }
    }
}
 
	void destroyPresentResources() {
		vkl::destroySwapchain(_Logical, _Swapchain);
		vkl::destroyRenderPass(_Logical, _RenderPass);
		vkl::destroyImageView(_Logical, _DepthImageView);
		vkl::destroyImage(_Logical, _DepthImage);
		vkl::freeMemory(_Logical, _AttachmentMemory);
		for (size_t i = 0; i < _ImageResources.size(); ++i) {
			vkl::destroyCommandPool(_Logical, _ImageResources[i].commandPool);
			vkl::destroyFramebuffer(_Logical, _ImageResources[i].framebuffer);
			vkl::destroyImageView(_Logical, _ImageResources[i].imageView);
		}
	}
